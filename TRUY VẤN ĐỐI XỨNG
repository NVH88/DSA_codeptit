Cách này vẫn TLE

#include<bits/stdc++.h>
using namespace std;
#define ll long long

const int maxn = 100005, base = 11, M = 1e9 + 7;
ll t1[4 * maxn], t2[4 * maxn], p[maxn];
string s1, s2;

void poww() {
	p[0] = 1;
	for(int i = 1; i <= 100000; i++) {
		p[i] = (p[i - 1] % M * base) % M;
	}
}

void build(int i, int l, int r, ll tree[], string s) {
	if(l == r) tree[i] = s[l] - '0' + 1;
	else {
		int m = (l + r) / 2;
		build(2 * i, l, m, tree, s);
		build(2 * i + 1, m + 1, r, tree, s);
		tree[i] = ((tree[2 * i] * p[r - m]) % M + tree[2 * i + 1]) % M;
	}
}

void update(int i, int l, int r, int idx, int val, ll tree[]) {
	if(l == r) tree[i] = val + 1;
	else {
		int m = (l + r) / 2;
		if(idx <= m) update(2 * i, l, m, idx, val, tree);
		else update(2 * i + 1, m + 1, r, idx, val, tree);
		tree[i] = ((tree[2 * i] * p[r - m]) % M + tree[2 * i + 1]) % M;
	}
}

ll query(int i, int tl, int tr, int l, int r, ll tree[]) {
	if(l > r) return 0;
	if(l == tl && r == tr) return tree[i];
	else {
		int tm = (tl + tr) / 2;
		return ((query(2 * i, tl, tm, l, min(r, tm), tree) * p[max(0, r - tm)]) % M + query(2 * i + 1, tm + 1, tr, max(tm + 1, l), r, tree)) % M;
	}
}

int main() {
	poww();
	cin >> s1;
	int len = s1.length();
	s2 = s1;
	reverse(s2.begin(), s2.end());
	s1 = " " + s1;
	s2 = " " + s2;
	build(1, 1, len, t1, s1);
	build(1, 1, len, t2, s2);
	int n; cin >> n;
	while(n--) {
		char x; int y, z; cin >> x >> y >> z;
		if(x == 'q') {
			if(query(1, 1, len, y, z, t1) == query(1, 1, len, len - z + 1, len - y + 1, t2)) cout << "YES" << endl;
			else cout << "NO" << endl;
		}
		else {
			update(1, 1, len, y, z, t1);
			update(1, 1, len, len - y + 1, z, t2);
		}
	}
}
